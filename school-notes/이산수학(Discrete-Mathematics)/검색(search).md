# 탐색
## 탐색의 개념
### 탐색이란?
**`Search`**
- 방대한 데이터에서 `목적에 맞는 데이터`를 찾는 알고리즘
- 탐색 키(`Search Key`): 탐색하고자 하는 자료를 구별해 주는 항목

## 탐색의 종류
### 수행되는 위치에 따른 분류
- 내부 탐색(`Internal Search`)
  - `메모리 내`에 존재하는 자료엔 대한 탐색
- 외부 탐색(`External Search`)
  - `외부에 있는 보조 기억 장치`에 있는 자료에 대한 탐색

### 탐색 방법에 따른 분류
- 비교 탐색 방식
  - 검색 대상의 키를 비교하여 탐색
  - 순차 탐색, 이진 탐색, 트리 탐색, ...
- 계산 탐색 방식
  - 계산을 통한 탐색
  - 해싱 탐색, ...

## 비교 탐색 방식
### 순차 탐색
`Sequential Search`
`일렬로 되어 있는 자료`를 처음부터 마지막까지 `순서대로` 탐색하는 방식
- 데이터 배열의 처음부터 끝까지 `차례대로 비교`하여 원하는 데이터를 탐색
- `일렬`로 되어 있는 모든 데이터에 적용 가능
  - 자료가 아주 많은 경우에는 비효율적
- 알고리즘이 매우 `단순`
  - `구현이 쉬움`
- `단방향`으로 탐색을 수행
  - 선형 탐색(Linear Search)

#### `정렬되어 있지 않은 자료`에서의 순차 탐색
- 첫 번째 원소부터 마지막 원소까지 차례대로 `키값이 일치하는 원소`가 있는지를 탐색
- 키 값이 일치하는 원소가 있으면 그 원소의 `주소를 반환`
- 키 값이 일치하는 원소가 없으면 `탐색 실패`

#### 코드 로직
```js
function sequentialSearch(a[], n, key)
  for(i = 0; i < n; i++)
    if(a[i] == key) return i;

  return -1; // false
```

- 평균 비교 횟수: $(1 + 2+ 3 + ... + n)/n = (n + 1)/2$
- 평균 시간 복잡도: $o(n)$

#### `정렬되어 있는 않은 자료`에서의 순차 탐색
- 첫 번째 원소부터 마지막 원소까지 차례대로 `키값이 일치하는 원소`가 있는지를 탐색
- 키 값이 일치하는 원소가 있으면 그 원소의 `주소를 반환`
- 탐색 위치의 원소가 키값보다 `작으면 다음 위치로 이동`
- 탐색 위치의 원소가 키값보다 `크면 탐색 실패`

#### 코드 로직
```js
function sequentialSearch(a[], n, key)
  i = 0;
  while(i < n)
    if(a[i] == key) return i;
    else if(a[i] < key) i = i + 1;
    else return -1;
```
- 평균 비교 횟수: $(1 + 2+ 3 + ... + n)/n = (n + 1)/2$
- 평균 시간 복잡도: $o(n)$

### 이진 탐색
`Binary Search`
- `자료의 가운데`에 있는 항목을 키 값과 비교하여 키 값이 더 `크면 오른쪽 부분을 탐색`, 키 값이 더 `작으면 왼쪽 부분을 탐색`
- 키 값을 찾을 때 까지 `이진 탐색을 반복 수행`
- `정렬이 되어 있는 자료`를 탐색하는 경우에만 사용 가능

#### 코드 로직
```js
function binarySearch(a[], left, right, key)
  l = left;
  r = right;

  while(l <= r)
    mid = (l + r) / 2;

    if(a[mid] > key) r = mid - 1;
    else if(a[mid] < key) l = mid + 1;
    else return mid;

  return -1;
```
- 평균 시간 복잡도: $o(\log{n})$
- **자료가 `정렬된 상태`로 있어야 함**
- 자료가 추가되거나 삭제된 경우 `사전 정렬 작업 필요`

#### 코드 로직
```js
function sequentialSearch(a[], n, key)
  i = 0;
  while(i < n)
    if(a[i] == key) return i;
    else if(a[i] < key) i = i + 1;
    else return -1;
```
- 평균 비교 횟수: $(1 + 2+ 3 + ... + n)/n = (n + 1)/2$
- 평균 시간 복잡도: $o(n)$

### 이진 트리 탐색
`Binary Tree Search`
- 모든 노드는 `서로 다른 유일한 키`를 갖는다.
- `왼쪽 서브 트리`에 있는 모든 노드는 루트 노드보다 `작은 키`를 갖는다.
- `오른쪽 서브 트리`에 있는 모든 노드는 루트 노드보다 `큰 키`를 가진다.
- 왼쪽 서브 트리와 오른쪽 서브 트리도 `이진 탐색 트리`이다.

#### 코드 로직
```C
function treeSearch(tree, key)
{
  if(tree == NULL) return NULL;

  if(tree -> data == key)
    return tree;
  else if(tree -> data > key)
    treeSearch(tree -> left, key);
  else
    treeSearch(tree -> right, key);
}
```
- 평균 시간 복잡도:
  - 편향 이진 트리: $o(n)$
  - 완전 이진 트리: $o(\log{n})$

## 계산 탐색 방식
### 해시 함수와 해싱 탐색
**`암호학적 해시 함수`**
- 임의의 크기를 가지는 데이터가 `H의 입력`이 될 수 있음
- 출력값(해시값)의 크기는 `고정`
- H의 계산이 매우 빠름
- 일방향성: $y$가 주어졌을 때 $H(x) = y$를 만족시키는 $x$를 계산하는 것은 거의 불가능
- 충돌 회피성: 충돌을 찾는 것은 거의 불가능
  - **약한 충돌 회피성**: $H(x) = y$를 만족시키는 $x, y$가 주어졌을 때 $H(x\prime) = y$이고 $x \neq x\prime$ 인 $x$를 계산하는 것은 거의 불가능
  - **강한 충돌 회피성**:

#### 해싱 탐색
- 비교 탐색 방식: `키 값을 비교`하여 탐색하고자 하는 항목에 접근
- 해싱 탐색: 키 값에 `산술적인 연산을 적용`하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근
- 해시 함수: 키 값으로 부터 `테이블의 주소`를 계산
- 해시 테이블: 해시 함수에 의해 계산된 주소로부터 직접 접근이 가능한 `테이블 형태`의 구조

##### 해시 테이블
- 해시 테이블은  $M$개의 버킷(Bucket)으로 구성
- 각 버킷은 한 개 이상의 `슬롯(Slot)`으로 구성됨

#### 해싱 탐색의 특징
- 키 값에 해시 함수를 적용한 결과 값으로부터 `주소`를 구하고, 구한 주소에 해당하는 `해시 테이블`로 이용하여 찾고자 하는 항목을 탐색
- 해시 테이블은 `버킷과 슬롯`으로 구성
- 해싱 함수에 의해 계산된 주소는 `버킷의 주소`
- 슬롯이 여러 개인 경우 `순차 탐색`을 통해 해당 슬롯을 탐색

**충돌의 발생**
- 충돌(Collision): 서로 다른 두 개의 키에 대하여 그 `해시값이 동일`한 경우
- 버킷에 할당된 슬롯 수보다 충돌이 더 많이 발생하게 되면 버킷에 더 이상 항목을 `저장 불가` => `오버플로우(overflow)` 발생 => 오버플로우를 해결하기 위한 방법이 필요

#### 좋은 해시 함수의 조건
**1. 계산이 빨라야 함**
- 비교 검색 방법에 비해 해싱 탐색이 효율적이려면 해싱 함수의 계산 속도가 빨라야 함
**2. 충돌이 적어야 함**
- 충돌이 많으면 오버플로우가 발생할 가능성이 증가함
**3. 해시 테이블에 고르게 분포할 수 있도록 주소를 만들어야 함**

### 해시 함수의 종류
- **나머지 함수**
  - `나머지 연산(mod)`을 사용하여 주소를 계산
  - 버킷의 개수 $M$에 대하여 $H(key) = key\ mode\  M$
  - $M$을 잘못 선택하면 충돌이 발생하는 경우가 많이 발생함 => $M$은 적당한 크기의 `소수`를 사용
- **폴딩 함수**
  - 키 값의 비트를 해시 테이블 크기의 비트수와 `같은 크기로 분할`한 후 분할된 부분을 `모두 더하여` 해시 주소를 계산
  - **쉬프트 폴딩(Shift Folding)함수**
    - 키를 `여러 부분으로 나눈 값`들을 더하여 주소로 사용
  - **경계 폴딩(Boundary Folding)함수**
    - 키의 이웃한 부분을 `거꾸로 더하여` 주소로 사용
- **중간 제곱(Mid Square) 함수**
  - `키값을 제곱한 결과값`에서 중간에 있는 적당한 비트를 주소로 사용

### 오버플로우 처리 방법
**오버플로우란?**
- 충돌(Collision): 서로 다른 두 개의 키에 대하여 `동일한 해시 테이블 주소`를 반환하는 것
- 오버플로우(overflow): 버킷에 할당된 슬롯 수보다 충돌이 더 많이 발생하게 되면 버킷에 더 이상 항목 `저장 불가` => 오버 플로우 발생

#### 충돌 or 오버플로우를 해결하는 방법
1. 선형조사법: 충돌이 일어난 항목을 해시 테이블의 `다른 위치에 저장`
   - 해시 함수로 구한 주소에 이미 다른 키가 저장되어 있으면 `그 다음 주소`가 비어 있는지 조사하고 키를 저장
   - 해시 함수로부터 얻어낸 주소에 이미 다른 데이터가 입력되어 있음을 발견하면 `다음 주소로 이동`해서 저장
   - 해시 테이블 $HK$에 대하여, 만약 충돌이 $HK[k]$에서 충돌이 발생하면 $HT[k+1], HT[k+2], ...$를 `순서대로 빈 저장공간`을 조사
   - 만약 테이블의 끝에 도달하게 되면 `다시 테이블의 처음`으로 이동
2. 체이닝: 해시 테이블의 하나의 위치가 여러 개의 항목을 저장할 수 있또록 해시 테이블의 `구조를 변경`
   - 해시 테이블은 `연결 리스트에 대한 포인터`를 관리
   - 실제 데이터는 `연결 리스트에 저장`
   - **체이닝 기법의 특징**
     - `연결 리스트 자료 구조`를 이용해 오버플로우 문제를 해결
     - 각 버킷에 고정된 슬롯이 아닌 삽입과 삭제가 용이한 `연결 리스트`를 할당
     - 버킷 내에서 원하는 항목을 탐색할 때는 연결 리스트를 `순차 탐색`
