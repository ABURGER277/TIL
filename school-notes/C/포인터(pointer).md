# Pointer란
> 작성중입니다...
## 포인터의 개념과 표현
### C언어의 특징
C언어에 대한 평가는 사람들마다 엇갈릴 수 있다.
**C언어의 특징**에는 융통성, 간결성, 저급언어(low level), 모듈성, 효율성, 이식성, 등이 있다.
그 C언어에서 가장 평이 엇갈리는 부분 중 하나가 `Pointer`이다.

### 포인터 개념
**메모리와 주소**
`int a;`라는 코드를 실행하면
a라는 변수가 만들어진다? 라는 뜻이 아니다.
이는 메모리에서 a로 사용할 공간을 할당 받는다는 뜻이다.
> 메모리:
>> 값 등을 저장할 수 있는 공간
>> PC에서 4GB의 메모리가 있다는 것은 1byte의 공간이 40억개가 있다는 것을 의미한다.
`int`형은 `4byte`의 크기를 지니고 있으니 `1byte` 4개를 할당받는다는 것이다.
`double b`라고 변수를 선언하면 `1byte`공간 8개를 할당받을 것이다.

메모리의 각 byte공간에는 주소라는 번호가 붙어있다.
이는 배열의 index와 유사한데 예를들면,
변수 a는 1000번~1003번의 공간을 차지하고,
변수 b는 1004번~1011번의 공간을 차지할 것이다.

변수의 주소를 출력 해본다면 각 변수가 차지하고 있는 공간들 중 가장 낮은 번호의 주소가 나온다.
```c
int a;
a = 8;
printf("%d, %d\n", a, &a);
// '&'는 주소 연산자이다. 변수의 주소를 결과값으로 반환한다.
```
예제에서는 1000이 출력될 것이고 이 프로그램을 실제로 실행시키면 이보다 더 큰 수가 출력될 것이다.

**그리고 이러한 변수의 주소를 다른 변수에 저장할 수 있는데, 이렇게 어떤 변수의 주소를 저장할 수 있는 변수를 포인터라고 부른다.**

### 포인터 선언
```c
int *c;
double *d;
```
변수명 앞에 `*`를 붙이게 되면 이 변수는 포인터가 된다.
이렇게 선언을 하게 되면 변수`c`는 **int형 변수의 주소를 저장할 수 있는 포인터**가 된다.
마찬가지로 변수`d`도 **dobule형 변수의 주소를 저장할 수 있는 포인터**가 된다.

### 포인터에 값 할당
예를 들어보자
```c
int a;
double b;
int *c;
double d;

c = &a;
d = &b;
```
`a`는 1000 ~ 1003번의 공간을 할당받으며,
`b`는 1004 ~ 1011번의 공간을 할당받는다.
`*c`는 1012 ~ 1015번의 공간을 할당받으며,
`*d`는 1016 ~ 1019번의 공간을 할당받는다.
**포인터는 변수의 주소(index)를 담고 있으며, 이는 정수형이다.**
`c = &a`라고 할당을 해 주었으니 c의 1012 ~ 1015번의 int형 공간에는 a의 주소인 1000이 저장되는 것이다.
마찬가지로 `d = &b`라고 할당을 해 주었으니 d의 1016 ~ 1019번의 공간에는 b의 주소인 1004가 저장된다.

### 포인터 간접 지정(*) 및 접근
이렇게 포인터에 주소를 저장한 다음에 그 주소에 가리키는 공간을 접근할 수 있는 연산자도 있다.
이를 **간접 지정 연산자 `*`**라고 한다.
간접 지정 연산자는 포인터에 들어 잇는 주소가 가리키는 공간에 접근할 수 있다.

`*`연산자는 곱셈의 의미로 사용되기도 하는데 이를 구별하는 방법은
어떠한 변수 앞에 단독으로 붙어있으면 `간접 지정 연산자`로, 두 변수 사이에 있으면 `곱셈`연산자로 구별할 수 있다.

위 예제에서 이어서 설명해보자.
```c
int a; // 1000 ~ 1003
double b; // 1004 ~ 1011
int *c; // 1012 ~ 1015
double *d; // 1016 ~ 1019

c = &a; // c = 1000
d = &b; // d = 1004
// 현재 c에는 1000번이라는 a의 주소가 저장되어 있다.
// c앞에 *을 붙이면 그 1000번지에 있는 공간이라는 의미가 된다.
*c = 8;
// *c = 8이라는 것은 1000번 주소에 8이라는 값을 할당한다는 것이고 즉 a = 8; 이라는 뜻과 동일하다.
*d = 3.14;
// *d = 3.14이라는 것은 1004번 주소에 8이라는 값을 할당한다는 것이고 즉 b = 3.14; 이라는 뜻과 동일하다.
```

### 포인터 개념 실습
다음 프로그램의 실행 순서를 따라가보자.
```c
int a, b, c; // 변수 3개를 메모리에 할당한다.
int *p, *q; // 포인터 2개를 메모리에 할당한다.

p = &a; // p에 a의 메모리 주소를 할당한다.
*p = 8; // p가 가리키는 변수(a)에 8이란 값을 할당한다. 즉, a = 8;
q = &b; // q에 b의 메모리 주소를 할당한다.
*q = 12; // q가 가리키는 변수(b)에 12라는 값을 할당한다. 즉, b = 12;
p = &c; // p에 c의 메모리 주소를 할당한다.
*p = a + *q; // p가 가리키는 변수(c) = a + q가 가리키는 변수(b)
// 즉 c = a + b;
printf("%d\n", *p); // p가 가리키는 변수(c)를 출력한다
// 20이 출력된다.
```

### 포인터의 자료형
포인터는 가리키는 대상의 자료형으로 자료형을 구분한다.
```c
int a;
double b;
int *c;
double d;

c = &a;
d = &b;
```
가리키는 대상이 `int`형이면 `int형 포인터`, 대상이 `double`형이면 `double형 포인터`라고 부른다.
가리키는 대상의 자료형이 다르다면 대입하지 말아야한다. **의도적으로 한다면 형변환 연산자를 사용해야 한다.**
예를 들면
```c
int a, *c;
double b, *d;

c = &a; // 할당 가능
d = &b; // 할당 가능
c = &b; // 할당 불가능
c = (int *)&b; // 형 변환하여 할당 가능
```

## 포인터의 활용
포인터는 C언어 안에서 다방면으로 활용된다.
- 함수: 참조에 의한 호출 모사
- 배열
- 자료구조
- 문자열
- 파일 입출력
등 C언의 핵심적인 개념이자 요소이다.

### 함수에서의 포인터의 활용
함수에서 포인터는 다음과 같이 사용할 수 있다.
- 함수가 참조에 의한 호출처럼 동작하게 만들 수 있다.
- 함수가 반환값이 여러 개인 함수인 것처럼 동작하게 만들 수 있다.

### 두 변수의 값을 바꾸는 함수
#### 값에 의한 호출 Pass by Value
두 개의 변수 x, y의 값을 바꾸는 `swap()`함수를 만들어보자.
```c
int main(void) {
  int x, y;
  x = 8;
  y = 12;
  swap(x, y);
  printf("x: %d, y: %d", x, y);
  return 0;
}

// 기존의 두 값을 바꾸는 함수부터 작성해보자.
void swap(int a, int b) {
  int tmp;
  tmp = a;
  a = b;
  b = tmp;
  return;
}
// 이 함수가 과연 정말 원하는대로 동작할까?
```
1. 처음 `main()`함수에서 x, y 두 개의 변수를 만든다(메모리에 할당한다).
2. `swap()`함수에서도 두 매개변수 a, b에 대하여 메모리에 할당한다.
3. `main()`함수에서 `swap()`함수를 호출한다.
4. `swap()`의 매개변수 a, b의 메모리는 `main()`의 x, y메모리에서 값을 복사해온다.
5. `swap()`함수 안에서 보면 a와 b의 값은 서로 바뀌었다.
6. 그러나 `main()`함수안의 x와 y값은 바뀌지 않았다. `x: 8, y: 12`가 출력된다.

**함수 내에서는 다른 함수의 변수들을 접근할 수 없다.**
따라서 swap이라는 함수 안에서 main함수의 변수를 변경할 수 없다.
따라서 함수의 진행이 포인터를 사용하도록 바꾸어야 한다.

#### 참조에 의한 호출 Call by Reference
```c
int main(void) {
  int x, y;
  x = 8;
  y = 12;
  swap(&x, &y);
  printf("x: %d, y: %d", x, y);
  return 0;
}

void swap(int *a, int *b) {
  int tmp;
  tmp = *a;
  *a = *b;
  *b = tmp;
  return;
}

// x: 12, y: 8
// 성공적으로 바뀌어 출력된다.
```
`값에 의한 호출`에서는 **인자와 매개변수 사이에 값**만 복사한다.
함수가 호출된 뒤에는 각자 다른 영역이다. 즉 변수를 공유하지 않는다.

이와 대비되는 개념이 바로 `참조에 의한 호출`이다.
`참조에 의한 호출`은 인자에 있는 변수가 **매개변수와 연결되거나 같은 변수**이다.
이는 포인터에 의한 주소 자체를 복사해오므로 변수를 공유한다.

C언어는 값에 의한 호출만 사용이 가능하다. 포인터를 이용하면 참조에 의한 호출을 표현할 수 있다.
따라서 함수안에서 어떤 짓을 하더라도 main함수의 변수가 변하지 않는다.

그러나 프로그램을 짜다 보면 필연적으로 호출된 함수가 호출된 함수안의 변수를 변경해야 할 때가 있으며, 이 때 `pointer`를 사용하여 `참조에 의한 호출`을 구현하도록 한다.
**포인터를 이용한다고 해서 값에 의한 호출이 아닌것은 아니다.**
포인터를 사용해도 값에 의한 호출을 하는것이며, 포인터의 주소를 통해 비슷하게 모사하는 것이다.

#### 개인적인 의견
포인터는 익숙해진다면 매우 좋아보인다.
이 `swap()`함수를 자바로 작성해보자.
```java
public class Main {
    public static void main(String[] args) {
        int[] values = {8, 12};
        swap(values);
        System.out.printf("x: %d, y: %d", values[0], values[1]);
    }

    public static void swap(int[] values) {
        int tmp = values[0];
        values[0] = values[1];
        values[1] = tmp;
    }
}
```
이런식으로 숫자들을 배열에 묶어서 보내 변경해야했을 것이다.
`Pointer`를 사용한다면 메모리 사용량이 최소화 될 것이다.

#### Pointer 예제 라이브러리(scanf)
**`scanf`**
`scanf`도 함수이다.(라이브러리 함수)
`main`에서 `scanf`를 호출했을 때, `main`내의 변수 값이 바뀔 수 있는가?
원래의 C언어라면 되지 않는다. 그러나 `scanf`는 `main`내의 값이 변경되며 이는 `Pointer`를 사용하기 때문이다.
```c
int main(void) {
  int a;
  scanf("%d", &a);
  // scanf로 a의 값이 변경 가능했는데, 지금 보니 a 앞에 '&'연산자가 붙어있다.
  // 이게 포인터의 주소연산자였던 것이다...
}
```

### 반환 값이 여러개인 함수의 모사
**C언어 에서의 반환값은 항상 1개이다.**
`return`한 다음에 값을 하나만 적을 수 있다.
그러나 어떤 동작을 한 결과가 반드시 1개일 수는 없을 것이다.

`Pointer`를 사용핟나면 반환값이 여러 개인 것처럼 동작하는 함수를 만들 수 있다.

#### 두개의 정수를 받아서 합과 차를 구하는 함수
정답부터 보면 아래와 같다.
```c
void sum_diff(int a, int b, int *c, int *d) {
  *c = a + b;
  *d = a - b;
  return;
}
```
이 함수를 보면 반환값이 있어야 할 것 같은데 막상 `void`로 함수가 선언되었다.
우리가 원하는건 `합(sum)`과 `차(diff)` 2개가 반환되야 할텐데?
`main`함수까지 이어서 작성해보자.
```c
int main(void) {
  int x, y;
  int n, m;

  x = 8;
  y = 12;
  sum_diff(x, y, &n, &m);
  ...
}
```
조금은 이해가 된다. 이렇게 하면 n과 m에 각각 x, y의 합과 차가 저장될 것이다.
즉 우리는 `n = x + y`, `m = x - y`로 n과 m을 사용할 수 있는 것이다.
