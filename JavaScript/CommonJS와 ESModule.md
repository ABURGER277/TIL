# CommonJS와 ESModule이란 무엇인가?
## 3줄 요약
1. CommonJS, ESModule은 외부 스크립트를 호출하기 위한 방식이다.
2. CommonJS는 Node에서 코드를 모듈화 시키기 위해 나온 방식이며, 브라우저에서 사용하기엔 조금 불편한점이 있음.
3. 위와 같은 불편함을 개선하기 위해 나온 스크립트 호출 방식이 ESModule

## 외부 스크립트 호출
우리는 코드를 짜고 코드를 정리한다.

스크립트를 만들어서 한 파일로 정리하고 사용할 곳에서 그 파일을 불러와야 하며, 때로는 외부 라이브러리 스크립트를 불러오기도 한다.

이 JS모듈을 불러오는 방식에는 두가지 방식이 있다.
1. `module.exports`로 모듈을 내보내며, `require()`로 호출 및 접근 (**CommonJS**)
2. `export`로 모듈을 내보내며 `import`로 호출 및 접근 (**ESModule**)

구체적인 예시를 들어보자.

### CommonJS 기본 문법
```JS
/** CommonJS */
// export할 utils.js
module.exports = { ... }

// 호출하는 main.js
const util = require('./utils');

// when you declare `http` in node
const http = require('http');
```

### ESModule 기본 문법
```JS
/** ESModule */
// export할 utils.js
export.default = () => { ... };

// 호출하는 main.js
import utils from './utils'

// when you declare `http` in node
import http from 'http'
```

## 대체 왜 두개나 있는가.
이 둘은 같은 기능을 한다.

근데 대체 왜 같은 기능을 하는 방식이 두가지나 생긴걸까.
보통 먼저 나온 방식의 단점이 있기에 하나가 출시했을 가능성이 높다.
각 방식의 출시일부터 알아보자.

- **CommonJS**
  CommonJS 모듈 시스템은 주로 Node.js 환경에서 사용되며, Node.js의 첫 버전이 공개된 2009년 즈음부터 널리 사용되기 시작했다.
  CommonJS는 서버 사이드 자바스크립트 개발을 위해 만들어졌다.

- **ES Module (ESM)**
  ES Module은 ECMAScript 2015(ES6) 표준의 일부로 공식적으로 도입되었으며, 2015년에 발표되었다.
  ESM은 브라우저와 Node.js 모두에서 점차 지원되기 시작했다.

`ESModule`이 `CommonJS`보다 6년 뒤에 나온것을 알 수 있다.
그럼 `CommonJS`를 알아보자.

## CommonJS
### 1. CommonJS의 등장 배경
- **모듈화 필요**
  - 초기 브라우저는 모듈 시스템을 기본적으로 제공하지 않았다.
  따라서 여러 개의 자바스크립트 파일을 `<script>` 태그로 개별 로드하는 방식만 지원되었다.
  - 자바스크립트 코드가 점차 복잡해지면서, 스크립트 안에서도 각 기능을 독립적인 모듈로 분리하여 관리할 필요가 있었다. CommonJS는 이를 통해 코드를 모듈 단위로 나누어 작성할 수 있게 하였다.

- **명확한 의존성 관리**
  - 파일 간 의존성과 **로드 순서**를 개발자가 수동으로 관리해야 했으므로, 복잡한 애플리케이션에서는 유지보수가 어려웠다.
  - 도입 이후 각 모듈이 `require()`를 통해 필요한 의존성을 명시적으로 불러올 수 있게 되어, 모듈 간의 관계와 흐름을 명확하게 관리할 수 있게 하였다.

- **코드 재사용성 향상**
  - **전역 네임스페이스 오염**
    - 기존에는 모든 스크립트가 전역 스코프에서 실행되었기 때문에, 변수 및 함수 이름 충돌 등의 문제가 발생하였다.
    - 모듈 단위로 분리된 코드는 다양한 프로젝트에서 손쉽게 재사용할 수 있게 되어, 개발 생산성을 높여준다.

## 2. CommonJS와 서버 사이드 모듈 시스템
- **Node.js의 등장**
  Node.js는 CommonJS 모듈 시스템을 채택하여, 서버 사이드 자바스크립트에서 모듈화와 의존성 관리를 효과적으로 해결했다.
- **서버와 브라우저의 격차**
  CommonJS는 동기적인 `require()` 방식을 사용하기 때문에 서버 사이드에서는 문제없이 작동하지만,
  브라우저 환경에서는 기본적으로 지원되지 않아 사용할 수 없었다.

## 3. 번들러의 등장: Browserify와 Webpack
- **Browserify**
  - Node.js의 CommonJS 모듈을 브라우저에서도 사용할 수 있도록 도와주는 도구다.
  - 개발자가 작성한 여러 CommonJS 모듈을 하나의 번들 파일로 합쳐, 브라우저에서 실행할 수 있게 변환한다.

- **Webpack**
  - 단순 번들러 이상의 기능을 제공하며, 자바스크립트 파일뿐 아니라 CSS, 이미지 등 다양한 자원을 하나의 번들로 관리할 수 있다.
  - 모듈 간 의존성을 분석하여 올바른 순서로 로드하고, 코드 스플리팅, 트리 쉐이킹, 압축 등 성능 최적화를 지원한다.

## 4. 번들러가 가져온 웹 개발 환경 개선 효과
- **모듈 시스템 통합**
  번들러 덕분에 서버 사이드에서 사용하던 CommonJS 모듈을 클라이언트 사이드에서도 사용할 수 있게 되었으며,
  ES Module 등 다양한 모듈 시스템을 한 프로젝트 내에서 혼용할 수 있게 되었다.

- **의존성 관리 및 최적화**
  번들러가 모듈 간 의존성을 자동으로 분석하고, 올바른 로드 순서를 결정해 줌으로써,
  개발자가 직접 스크립트 로드 순서를 관리하는 부담을 덜어주었다.
  또한, 불필요한 코드를 제거하고, 번들 크기를 줄이는 최적화 기법(예: 트리 쉐이킹, 코드 스플리팅)을 지원한다.

- **개발 생산성 향상**
  핫 모듈 교체(HMR)와 같은 기능을 통해 개발 중 코드 변경사항을 실시간으로 반영할 수 있어,
  개발과 디버깅 속도가 크게 개선되었다.

- **다양한 자원 관리**
  자바스크립트뿐만 아니라, CSS, 이미지, 폰트 등의 다양한 정적 자원을 함께 번들링하여
  프로젝트 관리와 배포를 단순화하였다.

### 5. 결론
초기 브라우저는 모듈 시스템이 없어서 코드 관리와 의존성 처리에 한계가 있었으나,
Node.js에서 CommonJS 모듈 시스템이 등장하면서 서버 사이드에서는 모듈화가 이루어졌다.
그러나 브라우저에서는 여전히 모듈 시스템이 없었기 때문에, Browserify와 Webpack과 같은 번들러가 등장해
서버 사이드에서 사용하던 모듈을 클라이언트 사이드로 쉽게 옮길 수 있게 되었고,
이를 통해 프론트엔드 개발 환경 또한 크게 개선되었다.

### 6. 단점
- **동기적 로딩 방식**
  - CommonJS는 `require()`를 사용해 모듈을 동기적으로 불러온다.
  - 모든 모듈을 한 번에 순서대로 불러오기 때문에, 모듈 로딩 시간이 길어지면 전체 실행이 지연될 수 있다.
  - 서버 사이드에서는 큰 문제가 없지만, 특히 브라우저와 같이 비동기 로딩이 필수인 환경에서는 부적합하다.
    - 네트워크 상태에 따라 애플리케이션이 멈추는 것처럼 보일 수 있다.

- **동적 구조로 인한 정적 분석의 어려움**
  - CommonJS는 런타임에 모듈을 불러오게 된다.
    - `require()`가 호출되야 모듈을 로드하게 된다.
  - 이로 인해, 번들러가 의존성을 빌드 타임에 정적으로 분석하기 어려워 트리 쉐이킹(tree shaking) 등의 최적화 기법 적용에 한계가 있다.

- **표준화 미흡**
  - CommonJS는 ECMAScript의 공식 표준이 아니라, Node.js 커뮤니티에서 만들어진 규약이다.
  - 이로 인해 언어 차원에서의 일관성과 통합 지원이 부족하다.

- **브라우저 환경과의 부조화**
  - 브라우저는 기본적으로 **CommonJS 모듈 시스템을 지원하지 않는다.**
  - 이로 인해 `Browserify`나 `Webpack`과 같은 번들러를 통해 변환하는 추가 작업이 필요했다.

## ESModule
### 1. 등장 배경
그렇다면 `ESModule`의 등장배경은 당연히 `CommonJS`의 단점을 해결했을 것이다.
- **정적 분석의 어려움 극복**
  - ESModule은 `import`와 `export` 구문을 사용해 모듈 의존성을 정적으로 선언한다.
  - 이로써 번들러가 코드 내 사용되지 않는 부분을 식별하여 트리 쉐이킹 등 최적화를 쉽게 수행할 수 있다.

- **비동기 로딩 지원**
  - CommonJS는 동기적으로 모듈을 로드하므로, 특히 브라우저 환경에서는 네트워크 지연 시 전체 실행이 지연될 수 있다.
  - ESModule은 브라우저에서 `<script type="module">`을 사용하여 비동기 로딩을 기본으로 지원한다.
  - 이로써 모듈을 효율적으로 로드할 수 있도록 하여 사용자 경험을 개선한다.

- **공식 표준화**
  - CommonJS는 Node.js 커뮤니티에서 제안된 규약으로, 공식 ECMAScript 표준이 아니다.
  - ESModule은 ECMAScript 2015(ES6)부터 공식 표준의 일부로 채택되어, 모든 환경(브라우저, Node.js 등)에서 일관된 모듈 동작을 보장한다.

- **명확한 의존성 관리**
  - ESModule은 정적 구조 덕분에 모듈 간의 의존성이 코드 상에 명확하게 드러난다.
  - 이는 코드 유지보수와 협업에 있어 큰 장점으로 작용하며, 개발자가 코드 흐름을 쉽게 이해할 수 있게 해준다.

### 2. 결론
작성일 기준 ESModule로 모듈 스크립트를 작성하는것이 가장 최선의 방법이다.

정적 분석이 용이해 모듈 간 의존성이 명확하게 드러나고, 이를 바탕으로 트리 쉐이킹과 같은 최적화 기법을 적용할 수 있다.
또한, 비동기 로딩을 기본으로 지원하여 브라우저 환경에서도 효율적으로 작동하며,
ECMAScript 표준의 일부로 채택됨에 따라 플랫폼 간 일관된 모듈 동작과 코드 재사용성이 크게 개선되었다.

결과적으로, ESModule은 최신 웹 및 Node.js 개발 환경에서 유지보수와 성능 최적화를 동시에 달성할 수 있도록 돕는 핵심 기술로 자리잡았다.

### 3. 단점과 사용 시 주의할 점
- **CommonJS와의 혼합 사용**
  - 기존 npm 라이브러리와 프레임워크 대부분은 CommonJS로 작성되었기 때문에, ESModule과 CommonJS를 동시에 사용하려면 별도의 설정이나 변환 과정이 필요하다.
  - 이로 인해 프로젝트 초기 설정이 복잡해질 수 있다.

- **설정 및 파일 확장자 문제**
  - Node.js에서는 ESModule 사용 시 `package.json`에 `"type": "module"`을 명시하거나, 파일 확장자를 `.mjs`로 지정해야 하는 등 추가적인 설정이 요구된다.
  - 이러한 설정은 초기 도입 시 혼란을 줄 수 있다.

- **비동기 로딩 기본**
  - ESModule은 기본적으로 비동기 로딩을 지원한다.
  - 이는 브라우저 환경에서는 장점이지만, 동기적 모듈 로딩에 익숙한 개발자나 레거시 코드와 통합할 때 불편할 수 있다.

- **동기적 코드 실행이 어려움**
  - 동기적 로딩이 필요한 경우(예: 모듈 초기화 순서를 보장해야 하는 상황)에는 ESModule의 비동기 로딩 방식이 제약으로 작용할 수 있다.

- **로드 성능 이슈**
  - 특정 상황에서 ESModule의 비동기 로딩 방식이 CommonJS에 비해 오버헤드를 발생시킬 수 있다.
  - 특히, 대규모 애플리케이션의 초기 로드 시점에서 성능 차이가 나타날 가능성이 있다.
